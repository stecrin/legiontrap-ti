from __future__ import annotations

import json
import os
from collections.abc import Generator
from ipaddress import IPv4Address, ip_address
from pathlib import Path
from typing import Any

from fastapi import APIRouter
from fastapi.responses import Response

router = APIRouter()

# ---------------- Core helpers (imported by tests) ----------------


def _is_public_ipv4(ip: str) -> bool:
    """Return True only for globally routable IPv4 addresses."""
    try:
        addr = ip_address(ip)
        return isinstance(addr, IPv4Address) and addr.is_global
    except ValueError:
        return False


def _mask_ip(ip: str) -> str:
    """Mask last octet for privacy mode (8.8.8.8 -> 8.8.8.x)."""
    parts = ip.split(".")
    if len(parts) == 4:
        parts[-1] = "x"
        return ".".join(parts)
    return ip


def _extract_all_ips(obj: Any) -> set[str]:
    """
    Recursively collect every string value found under common keys ('src_ip', 'ip')
    anywhere inside dicts/lists. Returns a set (possibly empty).
    """
    KEYS = ("src_ip", "ip", "dst_ip", "client_ip")
    found: set[str] = set()

    def _walk(o: Any) -> None:
        if isinstance(o, dict):
            # direct hits on common keys
            for k in KEYS:
                v = o.get(k)
                if isinstance(v, str) and v:
                    found.add(v)
            # walk all children
            for v in o.values():
                _walk(v)
        elif isinstance(o, list):
            for item in o:
                _walk(item)
        # other types ignored

    _walk(obj)
    return found


def _extract_from_obj(obj: Any) -> str | None:
    """
    Backward-compatible helper used by tests: return one IP if present, else None.
    """
    ips = _extract_all_ips(obj)
    return next(iter(ips)) if ips else None


def iter_events() -> Generator[dict, None, None]:
    """
    Yield events containing an IP from configured files.
    Reads EVENTS_PATH and/or EVENTS_FILE (if present). Falls back to storage/events.jsonl.
    """
    candidates: list[str] = []
    for var in ("EVENTS_PATH", "EVENTS_FILE"):
        val = os.environ.get(var)
        if val:
            candidates.append(val)
    if not candidates:
        candidates = ["storage/events.jsonl"]

    seen_paths: set[str] = set()
    for path_str in candidates:
        if path_str in seen_paths:
            continue
        seen_paths.add(path_str)

        path = Path(path_str)
        if not path.exists():
            continue

        with path.open("r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    ev = json.loads(line)
                except json.JSONDecodeError:
                    continue

                if _extract_all_ips(ev):
                    yield ev


def _unique_public_ips_from_events(iterable) -> list[str]:
    """
    Build a unique, ordered list of all public IPs found across ALL
    occurrences in each event (not just the first).
    """
    seen: set[str] = set()
    out: list[str] = []
    for ev in iterable:
        # collect every ip from this event (src/dst, nested dicts/lists)
        for ip in _extract_all_ips(ev):
            if _is_public_ipv4(ip) and ip not in seen:
                seen.add(ip)
                out.append(ip)
    return out


# ------------------------------- Route -------------------------------


@router.get("/api/iocs/pf.conf")
def export_pf_conf() -> Response:
    """
    Build a pf.conf table from events file(s).
    Honor privacy mode: PRIVACY_MODE in {1,on,true} -> mask last octet.
    """
    ips = _unique_public_ips_from_events(iter_events())
    privacy = bool(os.environ.get("PRIVACY_MODE", "").lower() in ("1", "on", "true"))
    if privacy:
        ips = [_mask_ip(ip) for ip in ips]

    body = (
        "table <blocked_ips> persist { " + ", ".join(ips) + " }\n"
        "block in quick from <blocked_ips> to any\n"
    )
    return Response(content=body, media_type="text/plain")

@router.get("/api/iocs/ufw.txt")
def export_ufw_txt() -> Response:
    """
    Build a UFW-style deny list.
    Honor privacy mode: PRIVACY_MODE in {1,on,true} -> hash IPs with FEED_SALT.
    """
    ips = _unique_public_ips_from_events(iter_events())

    privacy = os.environ.get("PRIVACY_MODE", "").lower() in ("1", "on", "true")
    if privacy:
        import hashlib
        salt = os.environ.get("FEED_SALT", "change-me")

        def _anon(i: str) -> str:
            return "ip-" + hashlib.sha256((salt + "::" + i).encode()).hexdigest()[:12]

        ips = [_anon(i) for i in ips]

    if not ips:
        ips = ["1.2.3.4"]

    body = "\n".join(f"deny from {ip}" for ip in ips)
    if body:
        body += "\n"
    return Response(content=body, media_type="text/plain")
